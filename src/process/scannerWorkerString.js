export const workerCode = `var h=require("worker_threads");var l=require("fs/promises"),w=async()=>{try{let f=(await l.readdir("/proc",{withFileTypes:!0})).filter((e)=>e.isDirectory()&&/^\\d+$/.test(e.name)).map(async(e)=>{let t=+e.name;try{let r=await Promise.race([l.readFile(\`/proc/\${t}/cmdline\`,"utf8"),new Promise((i,u)=>setTimeout(()=>u(new Error("Timeout")),100))]);try{if((await l.readFile(\`/proc/\${t}/status\`,"utf8")).includes("State:\\tT"))return null}catch(i){}let c;try{c=await l.readlink(\`/proc/\${t}/cwd\`)}catch(i){}let n=r.split("\\x00").filter((i)=>i.trim()!=="");return n.length?[t,n[0],n.slice(1),c]:null}catch{return null}});return(await Promise.all(f)).filter(Boolean)}catch(s){return console.error("Process discovery error:",s),[]}};var M=require("child_process"),P=()=>new Promise((s)=>M.exec("wmic process get ProcessID,ExecutablePath /format:csv",(f,o)=>{s(o.toString().split(\`\\r
\`).slice(2).map((e)=>{let t=e.trim().split(",").slice(1).reverse();return[parseInt(t[0])||t[0],t[1]]}).filter((e)=>e[1]))}));var z=process.platform==="linux"?w:P,b;function a(s){if(!a.cache)a.cache=new Map;if(a.cache.has(s))return a.cache.get(s);let o=s.toLowerCase().replaceAll("\\\\","/").split("/");if(/^[a-z]:$/.test(o[0])||o[0]==="")o.shift();let e=[],t=["64",".x64","x64","_64"];for(let r=0;r<o.length||r===1;r++){let c=o.slice(-r).join("/");if(!c)continue;e.push(c);for(let n of t)if(c.includes(n))e.push(c.replace(n,""))}if(a.cache.set(s,e),a.cache.size>1000){let r=a.cache.keys();a.cache.delete(r.next().value)}return e}function d(s,f,o,e){if(!s)return!1;if(!(!s.a||o&&o.includes(s.a)))return!1;return s.n.some((r)=>{if(r[0]===">")return r.substring(1)===f[0];return f.some((c)=>r===c||e&&\`\${e}/\${c}\`.includes(\`/\${r}\`))})}async function E(){let s=performance.now(),f=0;try{let o=await z();f=o.length;let e=new Set,t=new Map;for(let c of b)if(c.e&&c.e.n)for(let n of c.e.n){let i=n[0]===">"?n.substring(1):n;if(!t.has(i))t.set(i,[]);t.get(i).push(c)}for(let[c,n,i,u=""]of o){if(!n)continue;let g=a(n),y=new Set;for(let m of g)if(t.has(m))t.get(m).forEach((p)=>y.add(p));for(let m of y)try{let{e:p,i:_,n:x}=m;if(d(p,g,i,u))e.add({id:_,name:x,pid:c})}catch(p){h.parentPort.postMessage({type:"error",error:"Error during processing: "+p+\`
Caused by: \`+JSON.stringify(m)})}}let r=performance.now()-s;h.parentPort.postMessage({type:"scan_results",games:Array.from(e),stats:{scanTimeMs:r,processCount:f}})}catch(o){let e=performance.now()-s;h.parentPort.postMessage({type:"error",error:o.message,stats:{scanTimeMs:e,processCount:f}})}}h.parentPort.on("message",async(s)=>{switch(s.type){case"init":b=s.detectable,a.cache=new Map,h.parentPort.postMessage({type:"initialized"});break;case"scan":await E();break;case"clear_cache":if(a.cache)a.cache.clear();h.parentPort.postMessage({type:"cache_cleared"});break}});
`;